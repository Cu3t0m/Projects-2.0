import type { Comparator } from "@softwareventures/ordered";
export declare function copy<T>(array: ArrayLike<T>): T[];
export declare function isArray<T = unknown>(value: readonly T[] | unknown): value is readonly T[];
export declare function isArrayLike<T>(value: ArrayLike<T> | unknown): value is ArrayLike<T>;
export declare function coerce<T>(array: ArrayLike<T>): readonly T[];
export declare function first<T>(array: ArrayLike<T>): T | null;
/** @deprecated Use {@link first} instead. */
export declare function head<T>(array: ArrayLike<T>): T | null;
export declare function tail<T>(array: ArrayLike<T>): T[];
export declare function push<T>(array: ArrayLike<T>, value: T): T[];
export declare function pushFn<T>(value: T): (array: ArrayLike<T>) => T[];
export declare function unshift<T>(array: ArrayLike<T>, value: T): T[];
export declare function unshiftFn<T>(value: T): (array: ArrayLike<T>) => T[];
export declare function initial<T>(array: ArrayLike<T>): T[];
export declare function last<T>(array: ArrayLike<T>): T | null;
/** If the array contains exactly one element, returns that element.
 * Otherwise, returns null. */
export declare function only<T>(array: ArrayLike<T>): T | null;
export declare function empty<T>(array: ArrayLike<T>): boolean;
export declare function notEmpty<T>(array: ArrayLike<T>): boolean;
export declare function reverse<T>(array: ArrayLike<T>): T[];
export declare function slice<T>(array: ArrayLike<T>, start?: number, end?: number): T[];
export declare function sliceFn<T>(start?: number, end?: number): (array: ArrayLike<T>) => T[];
export declare function take<T>(array: ArrayLike<T>, count: number): T[];
export declare function takeFn<T>(count: number): (array: ArrayLike<T>) => T[];
export declare function drop<T>(array: ArrayLike<T>, count: number): T[];
export declare function dropFn<T>(count: number): (array: ArrayLike<T>) => T[];
export declare function takeWhile<T, U extends T>(array: ArrayLike<T>, predicate: (element: T, index: number) => element is U): U[];
export declare function takeWhile<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function takeWhileFn<T, U extends T>(predicate: (element: T, index: number) => element is U): (array: ArrayLike<T>) => U[];
export declare function takeWhileFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function takeUntil<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function takeUntilFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function dropWhile<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function dropWhileFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function dropUntil<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function dropUntilFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function equal<T>(a: ArrayLike<T>, b: ArrayLike<T>, elementsEqual?: (a: T, b: T) => boolean): boolean;
export declare function equalFn<T>(b: ArrayLike<T>, elementsEqual?: (a: T, b: T) => boolean): (a: ArrayLike<T>) => boolean;
export declare function notEqual<T>(a: ArrayLike<T>, b: ArrayLike<T>, elementsEqual?: (a: T, b: T) => boolean): boolean;
export declare function notEqualFn<T>(b: ArrayLike<T>, elementsEqual?: (a: T, b: T) => boolean): (a: ArrayLike<T>) => boolean;
export declare function prefixMatch<T>(a: ArrayLike<T>, b: ArrayLike<T>, elementsEqual?: (a: T, b: T) => boolean): boolean;
export declare function prefixMatchFn<T>(b: ArrayLike<T>, elementsEqual?: (a: T, b: T) => boolean): (a: ArrayLike<T>) => boolean;
export declare function map<T, U>(array: ArrayLike<T>, f: (element: T, index: number) => U): U[];
export declare function mapFn<T, U>(f: (element: T, index: number) => U): (array: ArrayLike<T>) => U[];
export declare function filter<T, U extends T>(array: ArrayLike<T>, predicate: (element: T, index: number) => element is U): U[];
export declare function filter<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function filterFn<T, U extends T>(predicate: (element: T, index: number) => element is U): (array: ArrayLike<T>) => U[];
export declare function filterFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function filterFirst<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function filterFirstFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function exclude<T, U>(array: ArrayLike<T | U>, predicate: (element: T | U) => element is T): U[];
export declare function exclude<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function excludeFn<T, U>(predicate: (element: T | U) => element is T): (array: ArrayLike<T | U>) => T[];
export declare function excludeFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function excludeNull<T>(array: ArrayLike<T | null | undefined>): T[];
export declare function excludeFirst<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function excludeFirstFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function remove<T>(array: ArrayLike<T>, value: T): T[];
export declare function removeFn<T>(value: T): (array: ArrayLike<T>) => T[];
export declare function removeFirst<T>(array: ArrayLike<T>, value: T): T[];
export declare function removeFirstFn<T>(value: T): (array: ArrayLike<T>) => T[];
export declare function fold<T, U>(array: ArrayLike<T>, f: (accumulator: U, element: T, index: number) => U, initial: U): U;
export declare function foldFn<T, U>(f: (accumulator: U, element: T, index: number) => U, initial: U): (array: ArrayLike<T>) => U;
export declare function fold1<T>(array: ArrayLike<T>, f: (accumulator: T, element: T, index: number) => T): T;
export declare function fold1Fn<T>(f: (accumulator: T, element: T, index: number) => T): (array: ArrayLike<T>) => T;
export declare function foldRight<T, U>(array: ArrayLike<T>, f: (accumulator: U, element: T, index: number) => U, initial: U): U;
export declare function foldRightFn<T, U>(f: (accumulator: U, element: T, index: number) => U, initial: U): (array: ArrayLike<T>) => U;
export declare function foldRight1<T>(array: ArrayLike<T>, f: (accumulator: T, element: T, index: number) => T): T;
export declare function foldRight1Fn<T>(f: (accumulator: T, element: T, index: number) => T): (array: ArrayLike<T>) => T;
export declare function foldMap<T, U>(array: ArrayLike<T>, f: (accumulator: U, element: U, index: number) => U, m: (element: T, index: number) => U, initial: U): U;
export declare function foldMapFn<T, U>(f: (accumulator: U, element: U, index: number) => U, m: (element: T, index: number) => U, initial: U): (array: ArrayLike<T>) => U;
export declare function foldMapRight<T, U>(array: ArrayLike<T>, f: (accumulator: U, element: U, index: number) => U, m: (element: T, index: number) => U, initial: U): U;
export declare function foldMapRightFn<T, U>(f: (accumulator: U, element: U, index: number) => U, m: (element: T, index: number) => U, initial: U): (array: ArrayLike<T>) => U;
export declare function contains<T>(array: ArrayLike<T>, value: T): boolean;
export declare function containsFn<T>(value: T): (array: ArrayLike<T>) => boolean;
export declare function indexOf<T>(array: ArrayLike<T>, value: T): number | null;
export declare function indexOfFn<T>(value: T): (array: ArrayLike<T>) => number | null;
export declare function findIndex<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): number | null;
export declare function findIndexFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => number | null;
export declare function find<T, U extends T>(array: ArrayLike<T>, predicate: (element: T) => element is U): U | null;
export declare function find<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T | null;
export declare function findFn<T, U extends T>(predicate: (element: T) => element is U): (array: ArrayLike<T>) => U | null;
export declare function findFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T | null;
export declare function maximum<T extends string | number | boolean>(array: ArrayLike<T>): T | null;
export declare function maximum<T>(array: ArrayLike<T>, compare: Comparator<T>): T | null;
export declare function maximumFn<T extends string | number | boolean>(): (array: ArrayLike<T>) => T | null;
export declare function maximumFn<T>(compare: Comparator<T>): (array: ArrayLike<T>) => T | null;
export declare function minimum<T extends string | number | boolean>(array: ArrayLike<T>): T | null;
export declare function minimum<T>(array: ArrayLike<T>, compare: Comparator<T>): T | null;
export declare function minimumFn<T extends string | number | boolean>(): (array: ArrayLike<T>) => T | null;
export declare function minimumFn<T>(compare: Comparator<T>): (array: ArrayLike<T>) => T | null;
export declare function sum(array: ArrayLike<number>): number;
export declare function product(array: ArrayLike<number>): number;
export declare function and(array: ArrayLike<boolean>): boolean;
export declare function or(array: ArrayLike<boolean>): boolean;
export declare function any<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): boolean;
export declare function anyFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => boolean;
export declare function all<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): boolean;
export declare function allFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => boolean;
export declare function concat<T>(arrays: ArrayLike<ArrayLike<T>>): T[];
export declare function prepend<T>(a: ArrayLike<T>): (b: ArrayLike<T>) => T[];
export declare function append<T>(b: ArrayLike<T>): (a: ArrayLike<T>) => T[];
export declare function concatMap<T, U>(array: ArrayLike<T>, f: (element: T, index: number) => ArrayLike<U>): U[];
export declare function concatMapFn<T, U>(f: (element: T, index: number) => ArrayLike<U>): (array: ArrayLike<T>) => U[];
export declare type NoneNull<T extends ArrayLike<unknown>> = {
    [K in keyof T]: NonNullable<T[K]>;
};
export declare function noneNull<T extends ArrayLike<unknown>>(array: T): NoneNull<T> | null;
export declare function scan<T, U>(array: ArrayLike<T>, f: (accumulator: U, element: T, index: number) => U, initial: U): U[];
export declare function scanFn<T, U>(f: (accumulator: U, element: T, index: number) => U, initial: U): (array: ArrayLike<T>) => U[];
export declare function scan1<T>(array: ArrayLike<T>, f: (accumulator: T, element: T, index: number) => T): T[];
export declare function scan1Fn<T>(f: (accumulator: T, element: T, index: number) => T): (array: ArrayLike<T>) => T[];
export declare function scanRight<T, U>(array: ArrayLike<T>, f: (accumulator: U, element: T, index: number) => U, initial: U): U[];
export declare function scanRightFn<T, U>(f: (accumulator: U, element: T, index: number) => U, initial: U): (array: ArrayLike<T>) => U[];
export declare function scanRight1<T>(array: ArrayLike<T>, f: (accumulator: T, element: T, index: number) => T): T[];
export declare function scanRight1Fn<T>(f: (accumulator: T, element: T, index: number) => T): (array: ArrayLike<T>) => T[];
/** Splits the array at the specified index.
 *
 * Returns a tuple where the first element is the first `index` elements of the
 * array, and the second element is the remaining elements of the array. */
export declare function split<T>(array: readonly T[], index: number): [T[], T[]];
/** Returns a function that splits an array at the specified index.
 *
 * This is the curried form of {@link split}. */
export declare function splitFn<T>(index: number): (array: readonly T[]) => [T[], T[]];
export declare function partition<T, U extends T>(array: ArrayLike<T>, predicate: (element: T) => element is U): [U[], Array<Exclude<T, U>>];
export declare function partition<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): [T[], T[]];
export declare function partitionFn<T, U extends T>(predicate: (element: T) => element is U): (array: ArrayLike<T>) => [U[], Array<Exclude<T, U>>];
export declare function partitionFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => [T[], T[]];
export declare function partitionWhile<T, U extends T>(array: ArrayLike<T>, predicate: (element: T) => element is U): [U[], T[]];
export declare function partitionWhile<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): [T[], T[]];
export declare function partitionWhileFn<T, U extends T>(predicate: (element: T) => element is U): (array: readonly T[]) => [U[], T[]];
export declare function partitionWhileFn<T>(predicate: (element: T) => boolean): (array: readonly T[]) => [T[], T[]];
export declare function partitionUntil<T>(array: ArrayLike<T>, predicate: (element: T) => boolean): [T[], T[]];
export declare function partitionUntilFn<T>(predicate: (element: T) => boolean): (array: ArrayLike<T>) => [T[], T[]];
/** Takes two arrays and returns an array of corresponding pairs.
 *
 * If one of the supplied arrays is shorter than the other, then the excess
 * elements of the longer array will be discarded. */
export declare function zip<T, U>(a: readonly T[], b: readonly U[]): Array<[T, U]>;
/** Returns a function that combines the elements of `a` with the elements of
 * `b` and returns an array of corresponding pairs.
 *
 * If one of the supplied arrays is shorter than the other, then the excess
 * elements of the longer array will be discarded.
 *
 * This is the curried variant of {@link zip}. */
export declare function zipFn<T, U>(b: readonly U[]): (a: readonly T[]) => Array<[T, U]>;
export declare function keyBy<TKey, TElement>(array: ArrayLike<TElement>, f: (element: TElement, index: number) => TKey): Map<TKey, TElement[]>;
export declare function keyByFn<TKey, TElement>(f: (element: TElement, index: number) => TKey): (array: ArrayLike<TElement>) => Map<TKey, TElement[]>;
export declare function keyFirstBy<TKey, TElement>(array: ArrayLike<TElement>, f: (element: TElement, index: number) => TKey): Map<TKey, TElement>;
export declare function keyFirstByFn<TKey, TElement>(f: (element: TElement, index: number) => TKey): (array: ArrayLike<TElement>) => Map<TKey, TElement>;
export declare function keyLastBy<TKey, TElement>(array: ArrayLike<TElement>, f: (element: TElement, index: number) => TKey): Map<TKey, TElement>;
export declare function keyLastByFn<TKey, TElement>(f: (element: TElement, index: number) => TKey): (array: ArrayLike<TElement>) => Map<TKey, TElement>;
export declare function mapKeyBy<TKey, TElement, TNewElement>(array: ArrayLike<TElement>, f: (element: TElement, index: number) => [TKey, TNewElement]): Map<TKey, TNewElement[]>;
export declare function mapKeyByFn<TKey, TElement, TNewElement>(f: (element: TElement, index: number) => [TKey, TNewElement]): (array: ArrayLike<TElement>) => Map<TKey, TNewElement[]>;
export declare function mapKeyFirstBy<TKey, TElement, TNewElement>(array: ArrayLike<TElement>, f: (element: TElement, index: number) => [TKey, TNewElement]): Map<TKey, TNewElement>;
export interface IdentityGrouping<T> {
    readonly identity: (element: T) => unknown;
}
export interface EqualityGrouping<T> {
    readonly equal: (a: T, b: T) => boolean;
    readonly hash?: (element: T, index: number) => unknown;
}
export interface OrderedGrouping<T> {
    readonly compare: Comparator<T>;
    readonly hash?: (element: T, index: number) => unknown;
}
export interface HashGrouping<T> {
    readonly hash: (element: T, index: number) => unknown;
}
export declare type Grouping<T> = IdentityGrouping<T> | EqualityGrouping<T> | OrderedGrouping<T> | HashGrouping<T>;
export declare function group<T>(array: ArrayLike<T>, grouping: Grouping<T>): T[][];
export declare function groupFn<T>(grouping: Grouping<T>): (array: ArrayLike<T>) => T[][];
export declare function groupByIdentity<T>(array: ArrayLike<T>, identity?: (element: T) => unknown): T[][];
export declare function groupByIdentityFn<T>(identity: (element: T) => unknown): (array: ArrayLike<T>) => T[][];
export declare function groupByEquality<T>(array: ArrayLike<T>, equal: (a: T, b: T) => boolean): T[][];
export declare function groupByEqualityFn<T>(equal: (a: T, b: T) => boolean): (array: ArrayLike<T>) => T[][];
export declare function groupByOrder<T>(array: ArrayLike<T>, compare: Comparator<T>): T[][];
export declare function groupByOrderFn<T>(compare: Comparator<T>): (array: ArrayLike<T>) => T[][];
export declare function groupByHash<T>(array: ArrayLike<T>, hash: (element: T, index: number) => unknown): T[][];
export declare function groupByHashFn<T>(hash: (element: T, index: number) => unknown): (array: ArrayLike<T>) => T[][];
export declare function groupByEqualityWithHash<T>(array: ArrayLike<T>, equal: (a: T, b: T) => boolean, hash: (element: T, index: number) => unknown): T[][];
export declare function groupByEqualityWithHashFn<T>(equal: (a: T, b: T) => boolean, hash: (element: T, index: number) => unknown): (array: ArrayLike<T>) => T[][];
export declare function groupByOrderWithHash<T>(array: ArrayLike<T>, compare: Comparator<T>, hash: (element: T, index: number) => unknown): T[][];
export declare function groupByOrderWithHashFn<T>(compare: Comparator<T>, hash: (element: T, index: number) => unknown): (array: ArrayLike<T>) => T[][];
export declare function groupAdjacent<T>(array: ArrayLike<T>, grouping: Grouping<T>): T[][];
export declare function groupAdjacentFn<T>(grouping: Grouping<T>): (array: ArrayLike<T>) => T[][];
export declare function groupAdjacentByIdentity<T>(array: ArrayLike<T>, identity?: (element: T) => unknown): T[][];
export declare function groupAdjacentByIdentityFn<T>(identity: (element: T) => unknown): (array: ArrayLike<T>) => T[][];
export declare function groupAdjacentByEquality<T>(array: ArrayLike<T>, equal: (a: T, b: T) => boolean): T[][];
export declare function groupAdjacentByEqualityFn<T>(equal: (a: T, b: T) => boolean): (array: ArrayLike<T>) => T[][];
export declare function groupAdjacentByOrder<T>(array: ArrayLike<T>, compare: Comparator<T>): T[][];
export declare function groupAdjacentByOrderFn<T>(compare: Comparator<T>): (array: ArrayLike<T>) => T[][];
export declare function groupAdjacentByHash<T>(array: ArrayLike<T>, hash: (element: T, index: number) => unknown): T[][];
export declare function groupAdjacentByHashFn<T>(hash: (element: T, index: number) => unknown): (array: ArrayLike<T>) => T[][];
export declare function unique<T>(array: ArrayLike<T>, grouping: Grouping<T>): T[];
export declare function uniqueFn<T>(grouping: Grouping<T>): (array: ArrayLike<T>) => T[];
export declare function uniqueByIdentity<T>(array: ArrayLike<T>, identity?: (element: T) => unknown): T[];
export declare function uniqueByEquality<T>(array: ArrayLike<T>, equal: (a: T, b: T) => boolean): T[];
export declare function uniqueByEqualityFn<T>(equal: (a: T, b: T) => boolean): (array: ArrayLike<T>) => T[];
export declare function uniqueByOrder<T>(array: ArrayLike<T>, compare: Comparator<T>): T[];
export declare function uniqueByOrderFn<T>(compare: Comparator<T>): (array: ArrayLike<T>) => T[];
export declare function uniqueByHash<T>(array: ArrayLike<T>, hash: (element: T, index: number) => unknown): T[];
export declare function uniqueByHashFn<T>(hash: (element: T, index: number) => unknown): (array: ArrayLike<T>) => T[];
export declare function uniqueByEqualityWithHash<T>(array: ArrayLike<T>, equal: (a: T, b: T) => boolean, hash: (element: T, index: number) => unknown): T[];
export declare function uniqueByEqualityWithHashFn<T>(equal: (a: T, b: T) => boolean, hash: (element: T, index: number) => unknown): (array: ArrayLike<T>) => T[];
export declare function uniqueByOrderWithHash<T>(array: ArrayLike<T>, compare: Comparator<T>, hash: (element: T, index: number) => unknown): T[];
export declare function uniqueByOrderWithHashFn<T>(compare: Comparator<T>, hash: (element: T, index: number) => unknown): (array: ArrayLike<T>) => T[];
export declare function uniqueAdjacent<T>(array: ArrayLike<T>, grouping: Grouping<T>): T[];
export declare function uniqueAdjacentFn<T>(grouping: Grouping<T>): (array: ArrayLike<T>) => T[];
export declare function uniqueAdjacentByIdentity<T>(array: ArrayLike<T>, identity?: (element: T) => unknown): T[];
export declare function uniqueAdjacentByIdentityFn<T>(identity: (element: T) => unknown): (array: ArrayLike<T>) => T[];
export declare function uniqueAdjacentByEquality<T>(array: ArrayLike<T>, equal: (a: T, b: T) => boolean): T[];
export declare function uniqueAdjacentByEqualityFn<T>(equal: (a: T, b: T) => boolean): (array: ArrayLike<T>) => T[];
export declare function uniqueAdjacentByOrder<T>(array: ArrayLike<T>, compare: Comparator<T>): T[];
export declare function uniqueAdjacentByOrderFn<T>(compare: Comparator<T>): (array: ArrayLike<T>) => T[];
export declare function uniqueAdjacentByHash<T>(array: ArrayLike<T>, hash: (element: T, index: number) => unknown): T[];
export declare function uniqueAdjacentByHashFn<T>(hash: (element: T, index: number) => unknown): (array: ArrayLike<T>) => T[];
/** @deprecated Use [array-shuffle](https://npmjs.com/array-shuffle) instead. */
export declare function shuffle<T>(array: ArrayLike<T>): T[];
export declare function sort(array: ArrayLike<boolean>): boolean[];
export declare function sort(array: ArrayLike<number>): number[];
export declare function sort(array: ArrayLike<string>): string[];
export declare function sort<T>(array: ArrayLike<T>, comparator: Comparator<T>): T[];
export declare function sortFn<T>(comparator: Comparator<T>): (array: ArrayLike<T>) => T[];
export declare function sortBy<T>(array: ArrayLike<T>, select: SortSelect<T>): T[];
export declare function sortByFn<T>(select: SortSelect<T>): (array: ArrayLike<T>) => T[];
export declare function sortByDescending<T>(array: ArrayLike<T>, select: SortSelect<T>): T[];
export declare function sortByDescendingFn<T>(select: SortSelect<T>): (array: ArrayLike<T>) => T[];
export declare type SortSelect<T> = ((element: T) => boolean) | ((element: T) => number) | ((element: T) => string);
export declare function forEach<T>(array: ArrayLike<T>, f: (element: T, index: number) => void): typeof array;
export declare function forEachFn<T>(f: (element: T, index: number) => void): (array: ArrayLike<T>) => typeof array;
